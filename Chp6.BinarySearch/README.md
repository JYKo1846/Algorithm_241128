# Chapter 6. 이분탐색 
문제 뒤의 알파벳&숫자 : 문제의 난이도 B(Bronze) S(Silver) G(Gold) P(Platinum) / 숫자가 작을수록 난이도가 높아짐

"정렬"되어있는 집합에서 원하는 값을 찾는 효율적인 탐색 방법

임의의 값과 원하는 값을 비교하여 탐색범위를 줄일 수 있다.

M을 [L:R] 사이의 중앙값 ((L+R)/2의 인덱스에 있는 값)으로 지정하여 조사 범위를 반으로 줄여가며

탐색하는 방법.

while(L<= R)
{
	mid= (L+R)/2;
	if(in[mid] < X) R= mid -1;
	else if(in[mid] > X) L= mid +1;
	else return true;
}

위와 같이 탐색하려는 값 X가 중앙값 in[mid]보다 작을 경우, R= mid -1 위치로 탐색 범위 절반을 줄이고
X가 중앙값 in[mid]보다 클 경우, L= mid +1 위치로 탐색 범위를 절반 줄여 탐색하는 

O(logN) 의 수행 시간을 가지는 탐색 방법이다.

### 0049. BOJ 1920 수 찾기. S4
:page_with_curl: https://www.acmicpc.net/problem/1920

```
N개의 수로 이루어진 배열에서 X라는 숫자가 존재하는지 묻는 M번의 질문에 답하는
프로그램을 구현하는 문제이다.

단, 시간 제한 조건이 1초이고, N <= 100000 / M <= 100000  N,M 모두 10만이므로

완전 탐색으로 구현할 경우 10만 X 10만으로 1초의 시간을 초과하게 된다.

따라서, 이분 탐색을 이용하여 M번의 질문에 대해 답하도록 구현하였음. PASS

```

### 0050. BOJ 14425 문자열 집합. S4
:page_with_curl: https://www.acmicpc.net/problem/14425

```
N개의 문자열로 이루어진 집합 S에 입력으로 주어지는 M개의 문자열이 몇개 포함되어 있는지 구하는 
프로그램 작성.

문자열 비교에는 시간 소요가 많이 걸리므로 이분 탐색으로 구현하였음.

문자열 비교 함수 Str.compare(비교하려는 문자열)을 수행하여, Str이 비교 문자열보다 작을 경우

(사전 순으로 작거나, 길이가 더 짧을 경우) 음수로

Str이 비교 문자열보다 클 경우 (사전 순으로 크거나, 길이가 더 길 경우) 양수를 반환

같을 경우 0이 반환되는 것을 이용하여

```
while(L<= R)
{
	mid= (L+R)/2;
	if(query.compare(in[mid]) < 0) R= mid -1;
	else if(query.compare(in[mid])> 0) L= mid +1;
	else 
	{
		res++;
		break;
	}
}
```

로 구현하면 탐색을 시간 내에 할 수 있게 된다.

```

### 0051. BOJ 2295 세 수의 합. G4
:page_with_curl: https://www.acmicpc.net/problem/2295

```
N개의 자연수들로 이루어진 집합 U. (5<= N <= 1000) 이 중 세 수(중복 선택 가능)를 선택하여 합 했을 때

U에 포함되는 수가 될 수 있다. 그럴 경우, 그 수 중 가장 큰 수를 출력하는 프로그램을 만드는 문제.

완전 탐색으로 집합의 모든 수들의 합을 구할 경우, 수행시간이 O(N*N*N) = O(N^3) 이 된다.

따라서, A+B+C= X 에서, A+B= X-C 가 가능한 것을 이용하여,

A+B 모든 조합을 저장, X-C와 비교하여 해당 조합이 있을 경우, 그 중 가장 큰 X를 저장하도록 구현하여 

해결하였음. 그럴 경우, 수행 시간은 O(N*N + N*N)= O(2*N^2) = O(N^2) 가 된다.

while(L<= R)
{
	mid= (L+R)/2;
	if(X-C < A+B[mid]) R= mid -1;
	else if(X-C > A+B[mid]) L= mid +1;
	else
	{
		result= result > X ? result : X;
		break;
	}
}

위와 같이 이분 탐색을 구현하여 PASS함.

```