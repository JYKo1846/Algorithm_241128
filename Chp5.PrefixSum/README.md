# Chapter 5. 구간합 
문제 뒤의 알파벳&숫자 : 문제의 난이도 B(Bronze) S(Silver) G(Gold) P(Platinum) / 숫자가 작을수록 난이도가 높아짐

Q개의 구간 합 쿼리, N개의 수로 이루어진 배열, K개의 배열 원소 갱신이 있을 때

| |배열 순회|누적합 배열|
|:---:|:---:|:---:|
|전처리|-|O(N)|
|구간 합 계산|O(N)|O(1)|
|배열 원소 갱신|O(1)|O(N)|
|전체 시간 복잡도|O(Q*N+K)|O(Q+N*K)|

※누적합 배열은 배열 원소 갱신이 있을 경우, 기존의 누적합도 모두 계산해야 되므로 O(N)

### 0043. BOJ 11659 구간 합 구하기4. S3
:page_with_curl: https://www.acmicpc.net/problem/11659

```
N개의 수로 이루어진 배열에서 M개의 i ~ j 까지의 구간합을 출력하도록 구현하는 문제.

배열 순회 형식으로 구현했을 때, 51%에서 시간 초과 당함.

Worst case의 경우, N과 M이 모두 10만 개일 때, O(10만 * 10만) 으로 시간초과.

따라서, 누적합 배열을 만들어 누적합을 미리 계산해 출력하도록 구현 PASS

cin >> N >> M;
for(i= 0; i< N; i++)
{
	cin >> in[i];
	acc[i]= acc[i-1]+ in[i];	// 누적합 계산식
}

```

### 0044. BOJ 16713 Generic Queries. S2
:page_with_curl: https://www.acmicpc.net/problem/16713

```
N개의 수로 이루어진 배열에 Q개의 쿼리에 대해 답변 하려고 함.

단 각 쿼리는 i ~ j 까지의 모든 값을 XOR한 값이다.

이때, 모든 쿼리의 값을 XOR한 값을 출력하는 문제.

누적합 배열을 사용하여 XOR한 값을 저장시킴. 2 ~ 4 까지의 XOR 값을 얻기 위해

누적합 배열을 이용해 알 수 있는 방법은 1 ~ 4 누적합 배열 XOR 1 ~ 1 까지의 값을 XOR하면 됨.

위대로 구현하여 PASS

```