# Chapter 5. 구간합 
문제 뒤의 알파벳&숫자 : 문제의 난이도 B(Bronze) S(Silver) G(Gold) P(Platinum) / 숫자가 작을수록 난이도가 높아짐

Q개의 구간 합 쿼리, N개의 수로 이루어진 배열, K개의 배열 원소 갱신이 있을 때

| |배열 순회|누적합 배열|
|:---:|:---:|:---:|
|전처리|-|O(N)|
|구간 합 계산|O(N)|O(1)|
|배열 원소 갱신|O(1)|O(N)|
|전체 시간 복잡도|O(Q*N+K)|O(Q+N*K)|

※누적합 배열은 배열 원소 갱신이 있을 경우, 기존의 누적합도 모두 계산해야 되므로 O(N)

### 0043. BOJ 11659 구간 합 구하기4. S3
:page_with_curl: https://www.acmicpc.net/problem/11659

```
N개의 수로 이루어진 배열에서 M개의 i ~ j 까지의 구간합을 출력하도록 구현하는 문제.

배열 순회 형식으로 구현했을 때, 51%에서 시간 초과 당함.

Worst case의 경우, N과 M이 모두 10만 개일 때, O(10만 * 10만) 으로 시간초과.

따라서, 누적합 배열을 만들어 누적합을 미리 계산해 출력하도록 구현 PASS

cin >> N >> M;
for(i= 0; i< N; i++)
{
	cin >> in[i];
	acc[i]= acc[i-1]+ in[i];	// 누적합 계산식
}

```

### 0044. BOJ 16713 Generic Queries. S2
:page_with_curl: https://www.acmicpc.net/problem/16713

```
N개의 수로 이루어진 배열에 Q개의 쿼리에 대해 답변 하려고 함.

단 각 쿼리는 i ~ j 까지의 모든 값을 XOR한 값이다.

이때, 모든 쿼리의 값을 XOR한 값을 출력하는 문제.

누적합 배열을 사용하여 XOR한 값을 저장시킴. 2 ~ 4 까지의 XOR 값을 얻기 위해

누적합 배열을 이용해 알 수 있는 방법은 1 ~ 4 누적합 배열 XOR 1 ~ 1 까지의 값을 XOR하면 됨.

위대로 구현하여 PASS

```

### 0045. BOJ 11660 구간 합 구하기5. S1
:page_with_curl: https://www.acmicpc.net/problem/11660

```
N X N의 수로 이루어진 2차원 배열에 Q개의 쿼리에 대해 답변 하려고 함.

각 행에 대해 누적합을 계산하여 X1 ~ X2 까지의 Y1 ~ Y2 구간의 누적합을 구해 

정답을 출력함. 상기했던 누적합 배열을 2차원으로 응용하여 해결함 PASS

다른 사람들의 제출현황을 보니 수행시간이 1/2임. ( 내 프로그램 : 228ms / 다른 C++ 프로그램 114ms)

이유 : 각 행에 대한 1차원 누적합이 아닌, 2차원 누적합을 적용하여 효율적으로 구현되도록 하였기 때문.

누적합 연산 시

acc[i][j]= acc[i-1][j] + acc[i][j-1] -acc[i-1][j-1] + in[i][j];

1. 필요한 범위 값 다 더하기.
2. 중복으로 더해진 범위 다시 빼기.
3. 현재값 더하기.

위와 같은 방법으로 구현하면 시간이 더욱 줄어들게 된다. 

ans= acc[tl_x][tl_y] - acc[hd_x - 1][tl_y] - acc[tl_x][hd_y-1] + acc[hd_x - 1][hd_y-1];

1. 필요한 범위를 모두 포함하는 구간합에서
2. 불필요한 범위의 구간합을 모두 배제
3. 중복으로 제거된 구간합 복원.

위 알고리즘 적용시 시간 복잡도 O(N^2+ M)
```

### 0046. BOJ 19951 태상이의 훈련소 생활. G5
:page_with_curl: https://www.acmicpc.net/problem/19951

```
배열의 모든 원소에 대해 모든 명령 수행 후 최종 값을 출력하는 문제. 단 입력 값의 범위 는 10만, 명령의 수 역시 10만

수행시간은 1초, 메모리 제한 512MB이다.

2중 for문을 사용하여 명령을 일일이 적용시 시간 초과가 자명. 누적합을 어떤 식으로 적용해야 할지 고민이 많았음.

변경해야 할 값만 나타내면 되지만, 어떤 식으로 나타낼 수 있을지 고민했음.

변화량을 1차원 배열에 대해 시작지점에 변화량을 기록. 종료지점+1 부터 -변화량을 할 경우, 복원까지 가능함을 알아냄.

위의 아이디어를 적용, 누적합으로 계산하도록 하였다.

ex) 범위 [1:5] +2 일 경우, in 배열 변화량의 값은 0 +2 +2 +2 +2 +2 -2 -2 -2 -2 -2 와 같이 될 수 있다.
이걸 단순화 하여, 0 +2 0 0 0 0 -2 0 0 0 0 이렇게 기록함.

예제를 그대로 적용하여 보면,

delta[]
[ 1: 5]  +2 => 0 +2  0  0  0  0 -2  0  0  0  0
[ 6:10]  +5 => 0 +2  0  0  0  0 +3  0  0  0  0 
[ 2: 7]  +2 => 0 +2 +2  0  0  0 +3  0 -2  0  0

최종 변화량 기록 배열 accDelta
    accDelta=> 0 +2 +4 +4 +4 +4 +7 +7 +5 +5 +5

	accDelta[i]= accDelta[i-1]+ delta[i]; 
	와 같이 계산하면, 적용된 변화량의 값과 새로 적용되어야 할 변화량의 값을 계산할 수 있다.

위의 accDelta[i] + in[i] 한 값을 출력하면 정답이 된다. 시간 복잡도 : O(N+M) 이 된다.


```

### 0047. BOJ 17232 생명 게임. G4
:page_with_curl: https://www.acmicpc.net/problem/17232

```
N * M 의 바둑판 내에 2K + 1 범위 내에 있는 생명의 수에 따라 생존 또는 탄생 또는 사망하는 조건에서

T 시간 이후 바둑판 위 살아있는 생명을 모두 출력하는 문제.

!! Code1. 완전 탐색으로 구현하였음.

매 시간 마다 2중 for 문으로 생명이 발견 되었을 때, after 바둑판의 해당 생명 범위 (2K+1)의 칸에 ++.

모든 생명을 탐색 후, after 바둑판을 탐색하여, 

i) before 바둑판에 생명이 있을 때, after 바둑판의 같은 칸에

생명의 수가 생존 or 사망하는지 확인 하여 before 바둑판 갱신.

ii) before 바둑판에 생명이 없을 때, after 바둑판의 같은 칸에

생명의 수가 탄생하는 조건에 만족할 경우를 확인하여 before 바둑판 갱신 

하도록 구현. 시간 복잡도 : O(T*N*M*rangeSearch()) => rangeSearch() : O(N*M)

총 시간 복잡도 : O(T*N*M*N*M) 이 되어, 최악의 경우 3000000 * 100 * 100 으로

시간 제한 2초를 초과. FAIL 하게 됨.


!! Code2. 누적합을 이용해, 해당 칸 범위의 생명이 몇개 있는지 미리 계산 & 생명의 상태를 판단하도록 구현.

결국, 이 문제는 해당 칸 2K + 1 주변의 범위에 생명이 얼마나 있는지 알면 

일일이 생명 하나하나에 계산을 할 필요 없이 바로 생명의 상태를 판단할 수 있는 문제이다.

따라서, 상태를 판단하기 전 미리 누적합으로 생명의 수를 계산, 특정 범위 내의 생명 수를 파악하도록 구현하는 코드.

setPrefixSum() 으로, 해당 칸까지의 생명의 수를 기록.

getRangeSum()으로, 해당 칸의 누적 생명 수를 확인하여, 생존 조건에 맞춰 생존 하도록 구현.

이 경우 시간 복잡도 O(T*N*M + N*M) = O(T*N*M) 으로, 최악의 경우, 300 * 100 * 100 = 3000000

시간 제한을 통과하여 PASS 하게 됨. PASS

주변 생명 수 연산을 먼저 계산 하도록 구현하여 동시 계산에 따른 시간 초과를 막게 구현함.

```
### 0048. BOJ 14476 최대공약수 하나 빼기. G2
:page_with_curl: https://www.acmicpc.net/problem/14476

```
N개의 자연수를 입력 받았을 때, 하나의 수를 제외시킨 후 입력 받은 수의 집합에서 나올 수 있는 가장 큰 

최대 공약수를 구하는 문제. 두 번 코드를 구현하였으며 두번째 코드에서 해결하였음.

첫번째 코드 : 

최대 공약수는 모든 수들의 공약수 중 가장 큰 수 이다.

따라서, 입력 받은 모든 수의 공약수가 몇번 나오는지 기록하여 한 수를 뺐을 때 공약수 중 나온 갯수가

N개와 같은 가장 큰 수를 출력하도록 구현하였음.

하지만, 공약수를 구하는 방식이 1 ~ sqrt(in[i])까지의 수를 일일이 나누어 나머지가 0이 되는지 확인하는 방식으로 확인하였으며,

수를 하나 뺄 때 역시, 뺀 수의 공약수를  위의 방식으로 하나하나 계산한 이후 판단하는 것 때문에 시간 초과를 받음.

따라서, 공약수를 다른 방법으로 구하는 것과 동시에 하나의 수를 뺸 이후의 공약수를 구하는 방식에도 시간을 줄일 수 있는 아이디어가

필요했음.

두번째 코드 : 

두가지의 문제점이 있다. 

i) 여러개의 수들의 최대 공약수를 어떻게 구할 지. 

ii) 수 하나를 뺀 이후 나머지 수의 최대 공약수를 누적합으로 구할지.

i의 해결 방법 ) 

유클리드 호제법을 사용하여, 두 수의 최대 공약수를 구하게 된다. 호제법을 이용하면 두수가 아닌, 여러개의 수가 있는

경우도 GCD ( Great Common Divisor 최대 공약수 ) 를 구할 수 있게 된다.

따라서, 이번 문제에선 유클리드 호제법 GCD(A, B)= GCD(B, A%B)를 이용하여 GCD를 구할 것이다.

코드에서 사용한 호제법

int gcd(int a, int b)
{
	while(b!= 0)
	{
		int r= a%b;
		a= b;
		b= r;
	}
	return a;
}

ii의 해결 방법 ) 

호제법을 이용하면 한번에 여러개의 수의 최대 공약수를 구할 수 있으나, 입력의 수가 최대 100만이기 때문에 

하나의 수를 뺸 이후 매번 최대공약수를 구할 경우 시간 초과는 자명한 일이다. O(N*(N-1)) = O(N^2)

따라서, 미리 최대 공약수를 구해놓는 누적합 방식으로 접근해야 된다.

그리고, GCD(A,B,C,D) = A,B의 GCD 와 C의 GCD 의 D와의 GCD와 같다. 

하지만, 한 방향으로 GCD를 구하게 될 경우 중간에 한 수를 뺀 후 GCD를 구하는 경우, 앞서 말했듯이

새로운 GCD를 구해야하기 때문에 문제가 있었다. 

ex) GCD(A, B, C, D, E) 에서 C를 뺄 경우 => GCD(GCD(GCD(A,B),D),E)를 새로 구해야 함.

따라서, 중간에 한 수를 빼도 문제 없도록 왼쪽-> 오른쪽으로 GCD , 오른쪽-> 왼쪽으로 GCD를 구하여

GCD(A,B,D,E)의 경우, GCD(GCD(A,B),GCD(D,E))로 해결할 수 있도록 구현 하였음.

for(i= 1; i<= N; i++)
	LGCD[i]= gcd(LGCD[i-1], in[i]);
for(i= N; i>= 1; i--)
	RGCD[i]= gcd(RGCD[i+1], in[i]);

위 코드는 아래와 같이 압축 가능하다.

for(i= 1; i<= N; i++)
{
	LGCD[i]= gcd(LGCD[i-1], in[i]);
	RGCD[N-i+1]= gcd(RGCD[N-i+2], in[N-i+1]);
}

위의 해결 방법으로 구현하여 시간 초과를 해결하고 PASS 하였음.
'''